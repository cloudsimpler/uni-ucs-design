/**
 * 请求拦截器队列
 */
import { UcsRequestOptions, UcsDefaultRequestOptions } from "./utssdk/interface";
import { arrayMerge, getRequestPrefix, getMergeOptions } from "./utssdk/tools";
/**
 * 请求体属性
 */
export type { UcsRequestOptions };

/**
 * 内部拦截器类型定义
 * @param options - 请求参数
 * @returns 处理后的请求参数
 */
type InternalInterceptor = (options : UcsRequestOptions) => Promise<UcsRequestOptions>;

/**
 * 请求前拦截器类型定义
 * @param options - 请求参数
 * @returns 处理后的请求参数
 */
type BeforeRequestInterceptor = (options : UcsRequestOptions) => Promise<UcsRequestOptions>;

/**
 * 请求成功拦截器类型定义
 * @param response - 响应数据
 * @returns 处理后的响应数据
 */
type SuccessRequestInterceptor = (response : UTSJSONObject) => Promise<UTSJSONObject>;

/**
 * 请求失败拦截器类型定义
 * @param fail - 失败信息
 * @returns 处理后的失败信息
 */
type FailRequestInterceptor = (fail : UTSJSONObject) => Promise<UTSJSONObject>;

/**
 * 请求完成拦截器类型定义（无论成功或失败都会执行）
 * @param all - 完整响应数据
 * @returns 处理后的响应数据
 */
type CompleteRequestInterceptor = (all : UTSJSONObject) => Promise<UTSJSONObject>;

/**
 * 请求管理器类
 * 提供请求拦截、全局配置、请求发起等功能
 */
export class RequestManager {
	/**
	 * 合并两个数组并去重
	 * @param p1 - 第一个数组
	 * @param p2 - 第二个数组
	 * @returns 合并去重后的新数组
	 */
	getArrayMerge(p1 : UTSJSONObject[], p2 : UTSJSONObject[]) : UTSJSONObject[] {
		return arrayMerge(p1, p2);
	};

	/**
	 * 合并两个数组，可选择是否刷新
	 * @param p1 - 第一个数组
	 * @param p2 - 第二个数组
	 * @param refresh - 是否刷新（true则直接返回p2，false则合并去重）
	 * @returns 合并后的数组
	 */
	getArrayMergeRefresh(p1 : UTSJSONObject[], p2 : UTSJSONObject[], refresh : boolean) : UTSJSONObject[] {
		if (refresh) {
			return p2;
		} else {
			return getArrayMerge(p1, p2);
		};
	};

	// 内部拦截器队列
	private internalInterceptors : InternalInterceptor[] = [];

	/**
	 * 添加内部拦截器(不对外提供，请勿使用)
	 * @param interceptor - 拦截器函数
	 */
	useInternalInterceptor(interceptor : InternalInterceptor) {
		this.internalInterceptors.push(interceptor);
	}

	/**
	 * 执行所有内部拦截器
	 * @param requestOptions - 请求参数
	 * @returns 处理后的请求参数
	 */
	private async runInternalInterceptors(options : UcsRequestOptions) : Promise<UcsRequestOptions> {
		for (const interceptor of this.internalInterceptors) {
			options = await interceptor(options);
		}
		return options;
	};



	// 请求前拦截器队列
	private beforeRequestInterceptors : BeforeRequestInterceptor[] = [];

	/**
	 * 添加请求前拦截器
	 * @param interceptor - 拦截器函数
	 */
	useBeforeRequestInterceptor(interceptor : BeforeRequestInterceptor) {
		this.beforeRequestInterceptors.push(interceptor);
	}

	/**
	 * 执行所有请求前拦截器
	 * @param requestOptions - 请求参数
	 * @returns 处理后的请求参数
	 */
	private async runBeforeRequestInterceptors(requestOptions : UcsRequestOptions) : Promise<UcsRequestOptions> {
		for (const interceptor of this.beforeRequestInterceptors) {
			requestOptions = await interceptor(requestOptions);
		}
		return requestOptions;
	};

	// 请求成功拦截器队列
	private successRequestInterceptors : SuccessRequestInterceptor[] = [];

	/**
	 * 添加请求成功拦截器
	 * @param interceptor - 拦截器函数
	 */
	useSuccessRequestInterceptor(interceptor : SuccessRequestInterceptor) {
		this.successRequestInterceptors.push(interceptor);
	}

	/**
	 * 执行所有请求成功拦截器
	 * @param response - 响应数据
	 */
	private async runSuccessRequestInterceptors(response : UTSJSONObject) : Promise<UTSJSONObject> {
		for (const interceptor of this.successRequestInterceptors) {
			response = await interceptor(response);
		};
		return response
	};

	// 请求失败拦截器队列
	private failRequestInterceptors : FailRequestInterceptor[] = [];

	/**
	 * 添加请求失败拦截器
	 * @param interceptor - 拦截器函数
	 */
	useFailRequestInterceptor(interceptor : FailRequestInterceptor) {
		this.failRequestInterceptors.push(interceptor);
	}

	/**
	 * 执行所有请求失败拦截器
	 * @param fail - 失败信息
	 */
	private async runFailRequestInterceptors(fail : UTSJSONObject) : Promise<UTSJSONObject> {
		for (const interceptor of this.failRequestInterceptors) {
			fail = await interceptor(fail);
		};
		return fail;
	};

	// 请求完成拦截器队列（无论成功或失败都会执行）
	private completeRequestInterceptors : CompleteRequestInterceptor[] = [];

	/**
	 * 添加请求完成拦截器
	 * @param interceptor - 拦截器函数
	 */
	useCompleteRequestInterceptor(interceptor : CompleteRequestInterceptor) {
		this.completeRequestInterceptors.push(interceptor);
	}

	/**
	 * 执行所有请求完成拦截器
	 * @param all - 完整响应数据
	 */
	private async runCompleteRequestInterceptors(all : UTSJSONObject) : Promise<UTSJSONObject> {
		for (const interceptor of this.completeRequestInterceptors) {
			all = await interceptor(all);
		};
		return all;
	};

	// 全局默认请求参数
	private defaultRequestOptions : UcsDefaultRequestOptions = {};

	/**
	 * 设置全局默认请求参数
	 * @param options - 自定义请求参数
	 */
	setRequestConfig(options : UcsDefaultRequestOptions) {
		this.defaultRequestOptions = options;
	};

	/**
	 * 获取当前设置的全局请求参数
	 * @returns 包含环境信息的全局请求参数
	 */
	getRequestConfig() {
		this.defaultRequestOptions.env = getRequestPrefix(this.defaultRequestOptions.production, this.defaultRequestOptions.development);
		return this.defaultRequestOptions;
	};

	/**
	 * 发起网络请求
	 * @param method - 请求方法（GET/POST/PUT等）
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async request(method : string, options : UcsRequestOptions) : Promise<RequestTask> {
		// 内部拦截器
		options = await this.runInternalInterceptors(options);
		// 合并全局参数
		options = await getMergeOptions(options, this.defaultRequestOptions);
		// 拦截器状态
		const closeInterceptor = !(options.closeInterceptor ?? false);
		// 执行请求之前的拦截器
		if (closeInterceptor) {
			options = await this.runBeforeRequestInterceptors(options);
		};
		// 发起请求
		const requestTask : RequestTask = await uni.request({
			method: method,
			url: options.url,
			data: options.data,
			header: options.header,
			timeout: options.requestTimeout ?? 60000,
			withCredentials: options.withCredentials,
			firstIpv4: options.firstIpv4,
			enableChunked: options.enableChunked,
			success: (res) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(res)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runSuccessRequestInterceptors(transferJson);
					};
					options.success?.(transferJson);
				})();
			},
			fail: (fail) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(fail)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runFailRequestInterceptors(transferJson);
					};
					options.fail?.(transferJson);
				})();
			},
			complete: (all) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(all)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runCompleteRequestInterceptors(transferJson);
					};
					options.complete?.(transferJson);
				})();
			}
		});
		// 返回请求Task
		options.requestTask?.(requestTask);

		return requestTask;
	};

	/**
	 * 发起GET请求
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async get(options : UcsRequestOptions) {
		return await this.request("GET", options);
	};

	/**
	 * 发起POST请求
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async post(options : UcsRequestOptions) {
		return await this.request("POST", options);
	};

	/**
	 * 发起PUT请求
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async put(options : UcsRequestOptions) {
		return await this.request("PUT", options);
	};

	/**
	 * 发起PATCH请求
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async patch(options : UcsRequestOptions) {
		return await this.request("PATCH", options);
	};

	/**
	 * 发起DELETE请求
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async delete(options : UcsRequestOptions) {
		return await this.request("DELETE", options);
	};

	/**
	 * 发起HEAD请求
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async head(options : UcsRequestOptions) {
		return await this.request("HEAD", options);
	};

	/**
	 * 发起OPTIONS请求
	 * @param options - 请求参数
	 * @returns RequestTask实例
	 */
	async options(options : UcsRequestOptions) {
		return await this.request("OPTIONS", options);
	};

	/**
	 * 上传文件
	 * @param options - 上传参数
	 * @returns UploadTask实例
	 */
	async uploadFile(options : UcsRequestOptions) : Promise<UploadTask> {
		// 内部拦截器
		options = await this.runInternalInterceptors(options);
		// 合并全局参数
		options = getMergeOptions(options, this.defaultRequestOptions);
		// 拦截器状态
		const closeInterceptor = !(options.closeInterceptor ?? false);
		// 执行所有请求之前的拦截器
		if (closeInterceptor) {
			options = await this.runBeforeRequestInterceptors(options);
		};
		// 发起上传请求
		const uploadTask : UploadTask = await uni.uploadFile({
			url: options.url,
			filePath: options.filePath,
			name: options.name,
			files: options.files,
			header: options.header,
			formData: options.formData,
			timeout: options.uploadFileTimeout ?? 120000,
			success: (res) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(res)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runSuccessRequestInterceptors(transferJson);
					};
					options.success?.(transferJson);
				})();
			},
			fail: (fail) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(fail)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runFailRequestInterceptors(transferJson);
					};
					options.fail?.(transferJson);
				})();
			},
			complete: (all) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(all)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runCompleteRequestInterceptors(transferJson);
					};
					options.complete?.(transferJson);
				})();
			}
		});
		// 返回上传Task
		options.uploadTask?.(uploadTask);

		return uploadTask;
	};

	/**
	 * 下载文件
	 * @param options - 下载参数
	 * @returns DownloadTask实例
	 */
	async downloadFile(options : UcsRequestOptions) : Promise<DownloadTask> {
		// 内部拦截器
		options = await this.runInternalInterceptors(options);
		// 合并全局参数
		options = getMergeOptions(options, this.defaultRequestOptions);
		// 拦截器状态
		const closeInterceptor = !(options.closeInterceptor ?? false);
		// 执行所有请求之前的拦截器
		if (closeInterceptor) {
			options = await this.runBeforeRequestInterceptors(options);
		};
		// 发起下载请求
		const downloadTask : DownloadTask = await uni.downloadFile({
			url: options.url,
			header: options.header,
			filePath: options.filePath,
			timeout: options.downloadFileTimeout ?? 120000,
			success: (res) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(res)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runSuccessRequestInterceptors(transferJson);
					};
					options.success?.(transferJson);
				})();
			},
			fail: (fail) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(fail)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runFailRequestInterceptors(transferJson);
					};
					options.fail?.(transferJson);
				})();
			},
			complete: (all) => {
				(async () => {
					let transferJson = JSON.parse(JSON.stringify(all)) as UTSJSONObject;
					transferJson.set("requestDetail", options);
					if (closeInterceptor) {
						transferJson = await this.runCompleteRequestInterceptors(transferJson);
					};
					options.complete?.(transferJson);
				})();
			}
		});
		// 返回下载Task
		options.downloadTask?.(downloadTask);

		return downloadTask;
	};
};

/**
 * 默认导出的HTTP请求实例
 * 可直接使用此实例发起请求
 */
const http = new RequestManager();
import { osRequestConfig } from "@/uni_modules/ucs-config"

// 内部拦截器
http.useInternalInterceptor(async (options : UcsRequestOptions) => {
	options.development = osRequestConfig['development'] as string;
	options.production = osRequestConfig['production'] as string;
	// #ifdef UNI-APP-X
	options.header = UTSJSONObject.assign(options.header ?? {}, osRequestConfig['header'] as UTSJSONObject);
	// #endif
	// #ifndef UNI-APP-X
	options.header = Object.assign(options.header ?? {}, osRequestConfig['header']);
	// #endif
	options.requestTimeout = osRequestConfig['requestTimeout'] as number;
	options.uploadFileTimeout = osRequestConfig['uploadFileTimeout'] as number;
	options.downloadFileTimeout = osRequestConfig['downloadFileTimeout'] as number;
	options.withCredentials = osRequestConfig['withCredentials'] as boolean;
	options.firstIpv4 = osRequestConfig['firstIpv4'] as boolean;
	options.enableChunked = osRequestConfig['enableChunked'] as boolean;
	return options;
});

export { http };